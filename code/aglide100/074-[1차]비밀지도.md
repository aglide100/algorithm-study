# 프로그래머스, [1차]비밀지도

> 출처: https://school.programmers.co.kr/learn/courses/30/lessons/17681

## 문제 설명

## 비밀지도

네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

1.  지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
2.  전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
3.  "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
4.  암호화된 배열은 지도의 각 가로줄에서 벽 부분을 `1`, 공백 부분을 `0`으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

![secret map](http://t1.kakaocdn.net/welcome2018/secret8.png "Secret Map")

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

### 입력 형식

입력으로 지도의 한 변 크기 `n` 과 2개의 정수 배열 `arr1`, `arr2`가 들어온다.

-   1 ≦ `n` ≦ 16
-   `arr1`, `arr2`는 길이 `n`인 정수 배열로 주어진다.
-   정수 배열의 각 원소 `x`를 이진수로 변환했을 때의 길이는 `n` 이하이다. 즉, 0 ≦ `x` ≦ 2n \- 1을 만족한다.

### 출력 형식

원래의 비밀지도를 해독하여 `'#'`, `공백`으로 구성된 문자열 배열로 출력하라.

### 입출력 예제

| 매개변수 | 값                                            |
| -------- | --------------------------------------------- |
| n        | 5                                             |
| arr1     | \[9, 20, 28, 18, 11\]                         |
| arr2     | \[30, 1, 21, 17, 28\]                         |
| 출력     | `["#####","# # #", "### #", "# ##", "#####"]` |

| 매개변수 | 값                                                           |
| -------- | ------------------------------------------------------------ |
| n        | 6                                                            |
| arr1     | \[46, 33, 33 ,22, 31, 50\]                                   |
| arr2     | \[27 ,56, 19, 14, 14, 10\]                                   |
| 출력     | `["######", "### #", "## ##", " #### ", " #####", "### # "]` |

[해설 보러가기](http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/)

# 문제 접근

2차원 배열을 두가지를 주었을때, 아래 두가지에 따라 전체 지도를 얻어내는 문제이다.

1. 두 지도중 어느한곳이라도 벽(1)이라면 전체지도에서도 벽이다.
2. 두 지도에서 둘다 공백(0)이라면 전체에서도 공백이다.

특이점이 있다면 배열을 이진수로 주는데, 이를 응용하여 시프트연산을 통해 좀더 다채롭게 풀이가 가능할 것으로 생각된다.

# 문제 풀이 코드

java

```java
class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        String[] answer = new String[n];

        for (int i=0; i<arr1.length; i++) {
            boolean[] arr_a = ToBinary(arr1[i], n);
            boolean[] arr_b = ToBinary(arr2[i], n);

            for (int k=0; k<n; k++) {
                if (arr_a[k] || arr_b[k]) {
                    arr_a[k] = true;
                } else if (!arr_a[k] && !arr_b[k]) {
                    arr_a[k] = false;
                }
            }

            String str = "";
            for (boolean b:arr_a) {
                if (b) {
                    str += "#";
                } else {
                    str += " ";
                }
            }

            answer[i] = str;
        }

        return answer;
    }

    public boolean[] ToBinary(int num, int n) {
        boolean[] arr = new boolean[n];
        int index = n-1;

        while (num > 0) {
            if (num % 2 != 0) {
                arr[index] = true;
            }

            num = num / 2;
            index--;
        }

        return arr;
    }
}
```
