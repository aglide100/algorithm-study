# 프로그래머스, 안전지대

> 출처: https://school.programmers.co.kr/learn/courses/30/lessons/120866

## 문제 설명

다음 그림과 같이 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다.  
![image.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/124a2c93-da99-4643-96a8-292bb871f553/image.png)  
지뢰는 2차원 배열 `board`에 1로 표시되어 있고 `board`에는 지뢰가 매설 된 지역 1과, 지뢰가 없는 지역 0만 존재합니다.  
지뢰가 매설된 지역의 지도 `board`가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return하도록 solution 함수를 완성해주세요.

---

##### 제한사항

-   `board`는 n \* n 배열입니다.
-   1 ≤ n ≤ 100
-   지뢰는 1로 표시되어 있습니다.
-   `board`에는 지뢰가 있는 지역 1과 지뢰가 없는 지역 0만 존재합니다.

---

##### 입출력 예

| board                                                                                                                                  | result |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| \[\[0, 0, 0, 0, 0\], \[0, 0, 0, 0, 0\], \[0, 0, 0, 0, 0\], \[0, 0, 1, 0, 0\], \[0, 0, 0, 0, 0\]\]                                      | 16     |
| \[\[0, 0, 0, 0, 0\], \[0, 0, 0, 0, 0\], \[0, 0, 0, 0, 0\], \[0, 0, 1, 1, 0\], \[0, 0, 0, 0, 0\]\]                                      | 13     |
| \[\[1, 1, 1, 1, 1, 1\], \[1, 1, 1, 1, 1, 1\], \[1, 1, 1, 1, 1, 1\], \[1, 1, 1, 1, 1, 1\], \[1, 1, 1, 1, 1, 1\], \[1, 1, 1, 1, 1, 1\]\] | 0      |

---

##### 입출력 예 설명

입출력 예 #1

-   (3, 2)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선 총 8칸은 위험지역입니다. 따라서 16을 return합니다.

입출력 예 #2

-   (3, 2), (3, 3)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선은 위험지역입니다. 따라서 위험지역을 제외한 칸 수 13을 return합니다.

입출력 예 #3

-   모든 지역에 지뢰가 있으므로 안전지역은 없습니다. 따라서 0을 return합니다..

# 문제 접근

2차원 배열에 지뢰가 있는 위치라면 상하좌우, 대각선까지 해서 도합 9개의 안전지대가 생긴다(벽에 막히지 않는 경우)

이는 for문안에 3칸만 움직이는 for를 통해 구현이 가능하고 전체 면적에서 처음 안전지대가 되는 경우에 하나씩 뺀다면 답을 구할 수 있다.

# 문제 풀이 코드

java

```java
class Solution {
    public int solution(int[][] board) {
        int answer = (int)Math.pow(board.length, 2);

        for (int x=0; x<board.length; x++) {
            for (int y=0; y<board.length; y++) {
                if (board[x][y] == 1) {
                    answer--;
                    for (int i=x-1; i<=x+1; i++) {
                        for (int l=y-1; l<=y+1; l++) {
                            if (i < 0 || l < 0 || i >= board.length || l >= board.length || (x==i && y==l)) {
                                continue;
                            }

                            if (board[i][l] == 0) {
                                answer--;
                                board[i][l] = -1;
                            }
                        }
                    }
                }
            }
        }
        return answer;
    }
}
```
